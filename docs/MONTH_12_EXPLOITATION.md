# Month 12 Exploitation Subsystem: Technical Documentation

## ğŸ¯ Overview

This document provides detailed technical documentation for the exploitation subsystem implemented in Month 12. It covers the Attack Path Router architecture, attack categories, tool mappings, risk levels, approval requirements, and integration with the agent's ReAct pattern.

## ğŸ—ï¸ Attack Path Router Architecture

### Component Overview

```
User Input (Natural Language)
    â†“
AttackPathRouter.classify_intent()
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Keyword Matching Engine    â”‚
â”‚   (10 category dictionaries) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
AttackCategory Enum
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   requires_approval()        â”‚
â”‚   (dangerous category check) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“ (if dangerous)           â†“ (if safe)
Approval Workflow          Direct Execution
    â†“                          â†“
AttackPathRouter.get_attack_plan()
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Attack Plan Generation     â”‚
â”‚   - risk_level               â”‚
â”‚   - tools[]                  â”‚
â”‚   - steps[]                  â”‚
â”‚   - target                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
Tool Registry â†’ Tool Execution â†’ Result
```

### Classification Algorithm

The `classify_intent()` method uses a keyword-based matching approach:

1. **Input Normalization**: User input is converted to lowercase
2. **Keyword Scanning**: Each category's keyword list is checked against the input
3. **First Match**: The first matching category is returned
4. **Fallback**: If no category matches, returns `None`

```python
def classify_intent(self, user_input: str) -> Optional[AttackCategory]:
    input_lower = user_input.lower()
    for category, keywords in self.keyword_map.items():
        for keyword in keywords:
            if keyword in input_lower:
                return category
    return None
```

### Attack Plan Structure

The `get_attack_plan()` method returns a structured dictionary:

```python
{
    "category": "cve_exploitation",
    "risk_level": "critical",
    "requires_approval": True,
    "target": {"host": "192.168.1.100", "port": 445},
    "tools": ["metasploit", "searchsploit", "nuclei"],
    "steps": [
        {"id": 1, "action": "search", "description": "Search for matching exploit modules"},
        {"id": 2, "action": "configure", "description": "Configure exploit parameters"},
        {"id": 3, "action": "execute", "description": "Execute the exploit module"},
        {"id": 4, "action": "verify", "description": "Verify exploitation success"}
    ]
}
```

## ğŸ“‹ Attack Categories

### Category Reference Table

| # | Category | Risk Level | Approval Required | Description |
|---|----------|-----------|-------------------|-------------|
| 1 | `CVE_EXPLOITATION` | Critical | âœ… Yes | Exploit known CVE vulnerabilities using Metasploit modules |
| 2 | `BRUTE_FORCE` | High | âœ… Yes | Brute force service credentials (SSH, FTP, SMB, etc.) |
| 3 | `WEB_APP_ATTACK` | High | âŒ No | Web application attacks (SQLi, XSS, CSRF, SSRF) |
| 4 | `PRIVILEGE_ESCALATION` | Critical | âœ… Yes | Escalate privileges on compromised systems |
| 5 | `LATERAL_MOVEMENT` | Critical | âœ… Yes | Move laterally across network hosts |
| 6 | `PASSWORD_SPRAY` | Medium | âŒ No | Password spraying and credential stuffing |
| 7 | `SOCIAL_ENGINEERING` | Medium | âŒ No | Social engineering and phishing campaigns |
| 8 | `NETWORK_PIVOT` | High | âŒ No | Network pivoting and tunneling |
| 9 | `FILE_EXFILTRATION` | High | âŒ No | Data exfiltration from compromised systems |
| 10 | `PERSISTENCE` | Critical | âŒ No | Establish persistence on compromised systems |

### Keyword Mappings

Each category has a set of keywords used for intent classification:

| Category | Keywords |
|----------|----------|
| `CVE_EXPLOITATION` | cve, exploit, vulnerability, advisory, patch, remote code execution, rce, zero-day |
| `BRUTE_FORCE` | brute force, brute-force, crack, wordlist, dictionary attack, hydra, john |
| `WEB_APP_ATTACK` | sql injection, sqli, xss, cross-site, web app, webapp, csrf, ssrf, injection, web application |
| `PRIVILEGE_ESCALATION` | privilege escalation, privesc, priv esc, root, admin, sudo, suid, escalate |
| `LATERAL_MOVEMENT` | lateral movement, lateral, move laterally, psexec, wmi, ssh hop, spread |
| `PASSWORD_SPRAY` | password spray, spray, credential stuffing, default credentials, common passwords |
| `SOCIAL_ENGINEERING` | social engineering, phishing, spear phishing, pretexting, vishing, smishing |
| `NETWORK_PIVOT` | network pivot, pivot, tunnel, port forward, proxy, socks, chisel, ligolo, pivoting |
| `FILE_EXFILTRATION` | exfiltrate, exfiltration, data theft, steal, extract data, download files, dump |
| `PERSISTENCE` | persistence, backdoor, implant, cron, scheduled task, registry, startup, persist |

## ğŸ”§ Tool Mapping Per Category

### Tool Availability Matrix

| Category | Tool 1 | Tool 2 | Tool 3 |
|----------|--------|--------|--------|
| `CVE_EXPLOITATION` | metasploit | searchsploit | nuclei |
| `BRUTE_FORCE` | hydra | john | hashcat |
| `WEB_APP_ATTACK` | sqlmap | nikto | burp, nuclei, curl |
| `PRIVILEGE_ESCALATION` | linpeas | winpeas | metasploit |
| `LATERAL_MOVEMENT` | metasploit | crackmapexec | impacket |
| `PASSWORD_SPRAY` | crackmapexec | spray | hydra |
| `SOCIAL_ENGINEERING` | gophish | set | â€” |
| `NETWORK_PIVOT` | chisel | ligolo | ssh, metasploit |
| `FILE_EXFILTRATION` | curl | scp | netcat |
| `PERSISTENCE` | metasploit | cron | systemctl |

### Implemented Tool Classes

| Tool Class | Tool Name | Phase | Category |
|-----------|-----------|-------|----------|
| `ExploitExecuteTool` | `exploit_execute` | EXPLOITATION | CVE_EXPLOITATION |
| `BruteForceTool` | `brute_force` | EXPLOITATION | BRUTE_FORCE |
| `SessionManagerTool` | `session_manager` | EXPLOITATION | All exploitation |
| `FileOperationsTool` | `file_operations` | POST_EXPLOITATION | FILE_EXFILTRATION |
| `SystemEnumerationTool` | `system_enumerate` | POST_EXPLOITATION | All post-exploit |
| `PrivilegeEscalationTool` | `privilege_escalation` | POST_EXPLOITATION | PRIVILEGE_ESCALATION |

## âš ï¸ Risk Levels and Approval Requirements

### Risk Level Classification

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CRITICAL                          â”‚
â”‚  CVE_EXPLOITATION, PRIVILEGE_ESCALATION,            â”‚
â”‚  LATERAL_MOVEMENT, PERSISTENCE                      â”‚
â”‚  â†’ Highest impact, may cause system compromise      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      HIGH                            â”‚
â”‚  BRUTE_FORCE, WEB_APP_ATTACK,                       â”‚
â”‚  NETWORK_PIVOT, FILE_EXFILTRATION                   â”‚
â”‚  â†’ Significant impact, may trigger alerts           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     MEDIUM                           â”‚
â”‚  PASSWORD_SPRAY, SOCIAL_ENGINEERING                  â”‚
â”‚  â†’ Moderate impact, lower detection risk            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Approval Decision Flow

```python
DANGEROUS_CATEGORIES = {
    AttackCategory.CVE_EXPLOITATION,
    AttackCategory.BRUTE_FORCE,
    AttackCategory.PRIVILEGE_ESCALATION,
    AttackCategory.LATERAL_MOVEMENT,
}

def requires_approval(self, category: AttackCategory) -> bool:
    return category in self.DANGEROUS_CATEGORIES
```

### Approval Workflow

1. Agent classifies user intent â†’ AttackCategory
2. Router checks `requires_approval(category)`
3. If **True**: Agent pauses, sends approval request via WebSocket
4. Frontend renders `ApprovalModal` with attack plan details
5. User reviews risk level, steps, and tools
6. User clicks **Approve** or **Reject**
7. Frontend calls `POST /agent/approve` with `{thread_id, approved}`
8. Agent resumes execution (if approved) or aborts (if rejected)

## ğŸ“– Usage Examples

### Example 1: CVE Exploitation (Requires Approval)

**User Input:** `"Exploit CVE-2017-0144 on 192.168.1.100"`

```
1. classify_intent() â†’ CVE_EXPLOITATION
2. requires_approval() â†’ True
3. get_attack_plan() â†’ {
     category: "cve_exploitation",
     risk_level: "critical",
     tools: ["metasploit", "searchsploit", "nuclei"],
     steps: [search, configure, execute, verify]
   }
4. â†’ ApprovalModal displayed to user
5. â†’ User approves
6. â†’ ExploitExecuteTool.execute(
       module_path="exploit/windows/smb/ms17_010_eternalblue",
       rhosts="192.168.1.100",
       payload="windows/x64/meterpreter/reverse_tcp"
     )
7. â†’ Session opened: Meterpreter session 1
8. â†’ SessionNode created in Neo4j
```

### Example 2: Brute Force SSH (Requires Approval)

**User Input:** `"Brute force SSH on 10.0.0.5"`

```
1. classify_intent() â†’ BRUTE_FORCE
2. requires_approval() â†’ True
3. get_attack_plan() â†’ {
     category: "brute_force",
     risk_level: "high",
     tools: ["hydra", "john", "hashcat"],
     steps: [configure, wordlist, execute, verify]
   }
4. â†’ ApprovalModal displayed
5. â†’ User approves
6. â†’ BruteForceTool.execute(
       target="10.0.0.5",
       service="ssh",
       username="admin",
       wordlist="/usr/share/wordlists/rockyou.txt"
     )
7. â†’ Maps to auxiliary/scanner/ssh/ssh_login
8. â†’ Credentials found, session opened
```

### Example 3: Web Application Attack (No Approval)

**User Input:** `"Test for SQL injection on http://target.com/login"`

```
1. classify_intent() â†’ WEB_APP_ATTACK
2. requires_approval() â†’ False
3. get_attack_plan() â†’ {
     category: "web_app_attack",
     risk_level: "high",
     tools: ["sqlmap", "nikto", "burp", "nuclei", "curl"],
     steps: [discover, test, exploit, report]
   }
4. â†’ Direct execution (no approval needed)
5. â†’ Agent uses available tools to test for SQLi
```

### Example 4: Post-Exploitation Enumeration

**User Input:** `"Enumerate the system info on session 1"`

```
1. classify_intent() â†’ None (handled by post-exploitation phase)
2. â†’ SystemEnumerationTool.execute(
       session_id="1",
       enum_type="all"
     )
3. â†’ Returns: sysinfo, users, network config, running processes
```

## ğŸ”— Integration with Agent ReAct Pattern

### ReAct Loop with Attack Router

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  THINK                               â”‚
â”‚  1. Receive user message                             â”‚
â”‚  2. AttackPathRouter.classify_intent(message)        â”‚
â”‚  3. Determine if approval needed                     â”‚
â”‚  4. Generate attack plan                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ACT                                â”‚
â”‚  1. If approval needed â†’ pause, request approval     â”‚
â”‚  2. Select tool from registry (phase-filtered)       â”‚
â”‚  3. Execute tool with parameters                     â”‚
â”‚  4. Track session if opened                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 OBSERVE                              â”‚
â”‚  1. Parse tool output                                â”‚
â”‚  2. Check for sessions/credentials                   â”‚
â”‚  3. Store results in Neo4j graph                     â”‚
â”‚  4. Update agent state (progress, phase)             â”‚
â”‚  5. Decide next action or report to user             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Phase-Based Tool Access

The tool registry enforces phase boundaries during the ReAct loop:

| Phase | Available Tool Categories |
|-------|--------------------------|
| INFORMATIONAL | Reconnaissance tools (Naabu, Curl, Nuclei, query_graph, web_search) |
| EXPLOITATION | Exploitation tools (exploit_execute, brute_force, session_manager) |
| POST_EXPLOITATION | Post-exploitation tools (file_operations, system_enumerate, privilege_escalation) |

### Agent State Integration

New state fields support the exploitation workflow:

```python
class AgentState(TypedDict):
    # ... existing fields ...
    pending_approval: Optional[dict]   # Approval request data
    guidance: Optional[str]            # Live user guidance
    progress: Optional[dict]           # Execution progress
    checkpoint: Optional[dict]         # Resume checkpoint
```

### WebSocket Message Types

The exploitation subsystem adds new WebSocket message types:

| Message Type | Direction | Purpose |
|-------------|-----------|---------|
| `approval_request` | Agent â†’ Frontend | Request user approval for dangerous operation |
| `approval_response` | Frontend â†’ Agent | User's approve/reject decision |
| `progress_update` | Agent â†’ Frontend | Real-time execution progress |
| `guidance` | Frontend â†’ Agent | Live user guidance injection |
| `stop` | Frontend â†’ Agent | Pause agent execution |
| `resume` | Frontend â†’ Agent | Resume agent execution |

## ğŸ“ File Structure

```
backend/app/agent/
â”œâ”€â”€ attack_path_router.py          # Attack path router & classification
â”œâ”€â”€ tools/
â”‚   â”œâ”€â”€ exploitation_tools.py      # ExploitExecute, BruteForce, SessionManager
â”‚   â””â”€â”€ post_exploitation_tools.py # FileOps, SystemEnum, PrivEsc
â”œâ”€â”€ state/
â”‚   â””â”€â”€ agent_state.py             # New state fields (pending_approval, etc.)

backend/app/api/
â”‚   â””â”€â”€ agent.py                   # New endpoints (stop, resume, guidance, approve)

backend/app/graph/
â”‚   â””â”€â”€ nodes.py                   # SessionNode, CredentialNode

frontend/components/chat/
â”‚   â”œâ”€â”€ ApprovalModal.tsx           # Approval workflow UI
â”‚   â””â”€â”€ ProgressStream.tsx          # Progress streaming UI

backend/tests/
â”‚   â””â”€â”€ test_integration_month_12.py  # Integration tests
```

## ğŸ”’ Security Architecture

### Defense in Depth

```
Layer 1: Intent Classification
    â†’ Only recognized attack categories proceed

Layer 2: Approval Workflow
    â†’ Dangerous operations require explicit user consent

Layer 3: Phase Access Control
    â†’ Tools restricted to appropriate operational phases

Layer 4: Session Isolation
    â†’ Multi-tenant session tracking (user_id, project_id)

Layer 5: Execution Control
    â†’ Stop/resume/guidance for real-time intervention
```

---

**Muhammad Adeel Haider**  
BSCYS-F24 A  
Supervisor: Sir Galib  
Date: March 2026
