"""
Exploitation Tools - Wrappers for Metasploit exploitation MCP server tools

These tools provide exploit execution, brute force, and session management capabilities.
"""

from typing import Dict, Any, Optional
from app.agent.tools.base_tool import BaseTool, ToolMetadata
from app.mcp.base_server import MCPClient
import logging

logger = logging.getLogger(__name__)

SERVICE_MODULE_MAP = {
    "ssh": "auxiliary/scanner/ssh/ssh_login",
    "ftp": "auxiliary/scanner/ftp/ftp_login",
    "smb": "auxiliary/scanner/smb/smb_login",
    "mysql": "auxiliary/scanner/mysql/mysql_login",
    "postgres": "auxiliary/scanner/postgres/postgres_login",
    "rdp": "auxiliary/scanner/rdp/rdp_login",
    "telnet": "auxiliary/scanner/telnet/telnet_login",
    "vnc": "auxiliary/scanner/vnc/vnc_login",
}


class ExploitExecuteTool(BaseTool):
    """Execute Metasploit exploit modules against targets"""

    def __init__(self, server_url: str = "http://kali-tools:8003"):
        """
        Initialize ExploitExecute tool.

        Args:
            server_url: URL of Metasploit MCP server
        """
        self.client = MCPClient(server_url)
        super().__init__()

    def _define_metadata(self) -> ToolMetadata:
        return ToolMetadata(
            name="exploit_execute",
            description="Execute a Metasploit exploit module against a target. Requires approval for execution.",
            parameters={
                "type": "object",
                "properties": {
                    "module_path": {
                        "type": "string",
                        "description": "Metasploit module path (e.g., 'exploit/unix/ftp/vsftpd_234_backdoor')"
                    },
                    "rhosts": {
                        "type": "string",
                        "description": "Target host IP or hostname"
                    },
                    "rport": {
                        "type": "integer",
                        "description": "Target port number"
                    },
                    "payload": {
                        "type": "string",
                        "description": "Payload to use (e.g., 'cmd/unix/interact')"
                    },
                    "lhost": {
                        "type": "string",
                        "description": "Local host for reverse connections"
                    },
                    "lport": {
                        "type": "integer",
                        "description": "Local port for reverse connections",
                        "default": 4444
                    }
                },
                "required": ["module_path", "rhosts"]
            }
        )

    async def execute(
        self,
        module_path: str,
        rhosts: str,
        rport: Optional[int] = None,
        payload: Optional[str] = None,
        lhost: Optional[str] = None,
        lport: int = 4444,
        **kwargs
    ) -> str:
        """Execute a Metasploit exploit module"""
        try:
            params: Dict[str, Any] = {
                "module_path": module_path,
                "rhosts": rhosts,
                "lport": lport,
            }
            if rport is not None:
                params["rport"] = rport
            if payload is not None:
                params["payload"] = payload
            if lhost is not None:
                params["lhost"] = lhost

            result = await self.client.call_tool("execute_module", params)

            if not result.get("success"):
                return f"Error: {result.get('error', 'Unknown error')}"

            session_opened = result.get("session_opened", False)
            session_info = result.get("session_info")

            output = f"Exploitation result for {rhosts}:\n"
            output += f"  Module: {module_path}\n"
            output += f"  Session Opened: {session_opened}\n"

            if session_info:
                output += f"  Session ID: {session_info.get('session_id', 'N/A')}\n"
                output += f"  Session Type: {session_info.get('type', 'N/A')}\n"
            else:
                output += "  No session was created.\n"

            raw_output = result.get("output", "")
            if raw_output:
                output += f"  Output: {raw_output}\n"

            return output

        except Exception as e:
            logger.error(f"ExploitExecute tool error: {e}", exc_info=True)
            return f"Error: {str(e)}"


class BruteForceTool(BaseTool):
    """Brute force attack tool using Metasploit auxiliary modules"""

    def __init__(self, server_url: str = "http://kali-tools:8003"):
        """
        Initialize BruteForce tool.

        Args:
            server_url: URL of Metasploit MCP server
        """
        self.client = MCPClient(server_url)
        super().__init__()

    def _define_metadata(self) -> ToolMetadata:
        return ToolMetadata(
            name="brute_force",
            description="Execute brute force attack against a service using Metasploit auxiliary modules.",
            parameters={
                "type": "object",
                "properties": {
                    "target": {
                        "type": "string",
                        "description": "Target IP or hostname"
                    },
                    "service": {
                        "type": "string",
                        "description": "Service to brute force (e.g., 'ssh', 'ftp', 'smb')"
                    },
                    "username": {
                        "type": "string",
                        "description": "Username to try (optional, uses wordlist if not provided)"
                    },
                    "wordlist": {
                        "type": "string",
                        "description": "Path to password wordlist",
                        "default": "/usr/share/wordlists/rockyou.txt"
                    }
                },
                "required": ["target", "service"]
            }
        )

    async def execute(
        self,
        target: str,
        service: str,
        username: Optional[str] = None,
        wordlist: str = "/usr/share/wordlists/rockyou.txt",
        **kwargs
    ) -> str:
        """Execute brute force attack against a service"""
        try:
            module_path = SERVICE_MODULE_MAP.get(service.lower())
            if not module_path:
                supported = ", ".join(sorted(SERVICE_MODULE_MAP.keys()))
                return f"Error: Unsupported service '{service}'. Supported services: {supported}"

            params: Dict[str, Any] = {
                "module_path": module_path,
                "rhosts": target,
                "pass_file": wordlist,
            }
            if username is not None:
                params["username"] = username

            result = await self.client.call_tool("execute_module", params)

            if not result.get("success"):
                return f"Error: {result.get('error', 'Unknown error')}"

            session_opened = result.get("session_opened", False)
            raw_output = result.get("output", "")

            output = f"Brute force results for {target} ({service}):\n"
            output += f"  Module: {module_path}\n"
            output += f"  Session Opened: {session_opened}\n"

            if raw_output:
                output += f"  Output:\n{raw_output}\n"
            else:
                output += "  No output returned.\n"

            return output

        except Exception as e:
            logger.error(f"BruteForce tool error: {e}", exc_info=True)
            return f"Error: {str(e)}"


class SessionManagerTool(BaseTool):
    """Manage Metasploit sessions"""

    def __init__(self, server_url: str = "http://kali-tools:8003"):
        """
        Initialize SessionManager tool.

        Args:
            server_url: URL of Metasploit MCP server
        """
        self.client = MCPClient(server_url)
        super().__init__()

    def _define_metadata(self) -> ToolMetadata:
        return ToolMetadata(
            name="session_manager",
            description="Manage Metasploit sessions - list sessions, execute commands in sessions.",
            parameters={
                "type": "object",
                "properties": {
                    "action": {
                        "type": "string",
                        "description": "Action to perform",
                        "enum": ["list", "command"]
                    },
                    "session_id": {
                        "type": "integer",
                        "description": "Session ID (required for 'command' action)"
                    },
                    "command": {
                        "type": "string",
                        "description": "Command to execute in session (required for 'command' action)"
                    }
                },
                "required": ["action"]
            }
        )

    async def execute(
        self,
        action: str,
        session_id: Optional[int] = None,
        command: Optional[str] = None,
        **kwargs
    ) -> str:
        """Manage Metasploit sessions"""
        try:
            if action == "list":
                result = await self.client.call_tool("list_sessions", {})

                if not result.get("success"):
                    return f"Error: {result.get('error', 'Unknown error')}"

                sessions = result.get("sessions", [])
                if not sessions:
                    return "No active sessions."

                output = "Active Metasploit sessions:\n"
                for session in sessions:
                    output += f"  Session {session.get('id', 'N/A')}:\n"
                    output += f"    Type: {session.get('type', 'N/A')}\n"
                    output += f"    Info: {session.get('info', 'N/A')}\n"

                return output

            elif action == "command":
                if session_id is None:
                    return "Error: session_id is required for 'command' action."
                if command is None:
                    return "Error: command is required for 'command' action."

                result = await self.client.call_tool(
                    "session_command",
                    {"session_id": session_id, "command": command}
                )

                if not result.get("success"):
                    return f"Error: {result.get('error', 'Unknown error')}"

                cmd_output = result.get("output", "")

                output = f"Session {session_id} command output:\n"
                output += f"  Command: {command}\n"
                output += f"  Output:\n{cmd_output}\n"

                return output

            else:
                return f"Error: Unknown action '{action}'. Supported actions: list, command"

        except Exception as e:
            logger.error(f"SessionManager tool error: {e}", exc_info=True)
            return f"Error: {str(e)}"
