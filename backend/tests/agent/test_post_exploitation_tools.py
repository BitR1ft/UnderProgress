"""Tests for post-exploitation tools (FileOperationsTool, SystemEnumerationTool, PrivilegeEscalationTool)."""

import pytest
from unittest.mock import Mock, AsyncMock
from app.agent.tools.post_exploitation_tools import (
    FileOperationsTool,
    SystemEnumerationTool,
    PrivilegeEscalationTool,
)


class TestFileOperationsToolInit:
    """Test FileOperationsTool initialization and metadata."""

    def test_initialization(self):
        """Test tool initializes with correct name."""
        tool = FileOperationsTool()
        assert tool.name == "file_operations"

    def test_description(self):
        """Test tool has a description mentioning file operations."""
        tool = FileOperationsTool()
        assert "file" in tool.description.lower()

    def test_custom_server_url(self):
        """Test tool accepts a custom server URL."""
        tool = FileOperationsTool(server_url="http://custom:9999")
        assert tool.client.server_url == "http://custom:9999"

    def test_parameters_schema(self):
        """Test tool metadata includes expected parameter keys."""
        tool = FileOperationsTool()
        props = tool.metadata.parameters["properties"]
        assert "action" in props
        assert "session_id" in props
        assert "remote_path" in props
        assert "local_path" in props

    def test_required_parameters(self):
        """Test required parameters are action, session_id, and remote_path."""
        tool = FileOperationsTool()
        required = tool.metadata.parameters["required"]
        assert "action" in required
        assert "session_id" in required
        assert "remote_path" in required

    def test_action_enum(self):
        """Test that action parameter has download, upload, and list options."""
        tool = FileOperationsTool()
        action_enum = tool.metadata.parameters["properties"]["action"]["enum"]
        assert "download" in action_enum
        assert "upload" in action_enum
        assert "list" in action_enum


class TestSystemEnumerationToolInit:
    """Test SystemEnumerationTool initialization and metadata."""

    def test_initialization(self):
        """Test tool initializes with correct name."""
        tool = SystemEnumerationTool()
        assert tool.name == "system_enumerate"

    def test_description(self):
        """Test tool has a description mentioning enumeration."""
        tool = SystemEnumerationTool()
        assert "enumerate" in tool.description.lower() or "enumerat" in tool.description.lower()

    def test_parameters_schema(self):
        """Test tool metadata includes expected parameter keys."""
        tool = SystemEnumerationTool()
        props = tool.metadata.parameters["properties"]
        assert "session_id" in props
        assert "enum_type" in props

    def test_required_parameters(self):
        """Test required parameters are session_id and enum_type."""
        tool = SystemEnumerationTool()
        required = tool.metadata.parameters["required"]
        assert "session_id" in required
        assert "enum_type" in required

    def test_enum_type_options(self):
        """Test that enum_type includes all expected options."""
        tool = SystemEnumerationTool()
        enum_values = tool.metadata.parameters["properties"]["enum_type"]["enum"]
        assert "sysinfo" in enum_values
        assert "users" in enum_values
        assert "network" in enum_values
        assert "processes" in enum_values
        assert "all" in enum_values


class TestPrivilegeEscalationToolInit:
    """Test PrivilegeEscalationTool initialization and metadata."""

    def test_initialization(self):
        """Test tool initializes with correct name."""
        tool = PrivilegeEscalationTool()
        assert tool.name == "privilege_escalation"

    def test_description(self):
        """Test tool has a description mentioning privilege escalation."""
        tool = PrivilegeEscalationTool()
        assert "privilege" in tool.description.lower()

    def test_parameters_schema(self):
        """Test tool metadata includes expected parameter keys."""
        tool = PrivilegeEscalationTool()
        props = tool.metadata.parameters["properties"]
        assert "session_id" in props
        assert "technique" in props
        assert "module_path" in props

    def test_required_parameters(self):
        """Test required parameters are session_id and technique."""
        tool = PrivilegeEscalationTool()
        required = tool.metadata.parameters["required"]
        assert "session_id" in required
        assert "technique" in required

    def test_technique_enum(self):
        """Test that technique parameter has expected options."""
        tool = PrivilegeEscalationTool()
        technique_enum = tool.metadata.parameters["properties"]["technique"]["enum"]
        assert "getsystem" in technique_enum
        assert "suggest" in technique_enum
        assert "exploit" in technique_enum


class TestSystemEnumerationCommands:
    """Test SystemEnumerationTool.ENUM_COMMANDS mapping."""

    def test_sysinfo_commands(self):
        """Test sysinfo maps to correct commands."""
        assert SystemEnumerationTool.ENUM_COMMANDS["sysinfo"] == ["sysinfo"]

    def test_users_commands(self):
        """Test users maps to getuid and whoami."""
        assert SystemEnumerationTool.ENUM_COMMANDS["users"] == ["getuid", "whoami"]

    def test_network_commands(self):
        """Test network maps to ipconfig."""
        assert SystemEnumerationTool.ENUM_COMMANDS["network"] == ["ipconfig"]

    def test_processes_commands(self):
        """Test processes maps to ps."""
        assert SystemEnumerationTool.ENUM_COMMANDS["processes"] == ["ps"]

    def test_all_categories_present(self):
        """Test all expected enumeration categories are present."""
        expected = {"sysinfo", "users", "network", "processes"}
        assert set(SystemEnumerationTool.ENUM_COMMANDS.keys()) == expected


@pytest.mark.asyncio
class TestFileOperationsToolExecute:
    """Test FileOperationsTool.execute() with mocked MCP client."""

    async def test_list_files(self):
        """Test listing files on compromised host."""
        tool = FileOperationsTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(return_value={
            "success": True,
            "output": "file1.txt\nfile2.txt\nsecret.conf",
        })

        result = await tool.execute(action="list", session_id=1, remote_path="/etc/")

        assert "list" in result
        assert "/etc/" in result
        assert "file1.txt" in result

    async def test_download_file(self):
        """Test downloading a file from the compromised host."""
        tool = FileOperationsTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(return_value={
            "success": True,
            "output": "Downloaded /etc/passwd",
        })

        result = await tool.execute(
            action="download",
            session_id=1,
            remote_path="/etc/passwd",
            local_path="/tmp/passwd",
        )

        assert "download" in result
        assert "/etc/passwd" in result

    async def test_upload_requires_local_path(self):
        """Test upload action without local_path returns error."""
        tool = FileOperationsTool()

        result = await tool.execute(action="upload", session_id=1, remote_path="/tmp/payload")

        assert "Error" in result
        assert "local_path" in result

    async def test_unknown_action(self):
        """Test unknown file action returns error."""
        tool = FileOperationsTool()

        result = await tool.execute(action="delete", session_id=1, remote_path="/tmp/file")

        assert "Error" in result
        assert "Unknown action" in result

    async def test_mcp_error_response(self):
        """Test handling MCP error response."""
        tool = FileOperationsTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(return_value={
            "success": False,
            "error": "Session not found",
        })

        result = await tool.execute(action="list", session_id=99, remote_path="/tmp")

        assert "Error" in result
        assert "Session not found" in result

    async def test_exception_handling(self):
        """Test handling unexpected exceptions."""
        tool = FileOperationsTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(side_effect=Exception("connection lost"))

        result = await tool.execute(action="list", session_id=1, remote_path="/tmp")

        assert "Error" in result
        assert "connection lost" in result


@pytest.mark.asyncio
class TestSystemEnumerationToolExecute:
    """Test SystemEnumerationTool.execute() with mocked MCP client."""

    async def test_sysinfo_enumeration(self):
        """Test sysinfo enumeration."""
        tool = SystemEnumerationTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(return_value={
            "success": True,
            "output": "OS: Linux 5.4.0\nArch: x86_64",
        })

        result = await tool.execute(session_id=1, enum_type="sysinfo")

        assert "sysinfo" in result
        assert "SYSINFO" in result
        assert "Linux" in result

    async def test_all_enumeration(self):
        """Test 'all' enumeration runs all categories."""
        tool = SystemEnumerationTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(return_value={
            "success": True,
            "output": "mock output",
        })

        result = await tool.execute(session_id=1, enum_type="all")

        assert "SYSINFO" in result
        assert "USERS" in result
        assert "NETWORK" in result
        assert "PROCESSES" in result
        # All categories should trigger commands
        assert tool.client.call_tool.await_count >= 4

    async def test_unknown_enum_type(self):
        """Test unknown enumeration type returns error."""
        tool = SystemEnumerationTool()

        result = await tool.execute(session_id=1, enum_type="unknown_type")

        assert "Error" in result
        assert "Unknown enum_type" in result

    async def test_partial_failure(self):
        """Test enumeration where some commands fail."""
        tool = SystemEnumerationTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(side_effect=[
            {"success": True, "output": "uid=0(root)"},
            {"success": False, "error": "Command failed"},
        ])

        result = await tool.execute(session_id=1, enum_type="users")

        assert "uid=0(root)" in result
        assert "Error" in result

    async def test_exception_handling(self):
        """Test handling unexpected exceptions."""
        tool = SystemEnumerationTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(side_effect=Exception("timeout"))

        result = await tool.execute(session_id=1, enum_type="sysinfo")

        assert "Error" in result
        assert "timeout" in result


@pytest.mark.asyncio
class TestPrivilegeEscalationToolExecute:
    """Test PrivilegeEscalationTool.execute() with mocked MCP client."""

    async def test_getsystem(self):
        """Test getsystem technique."""
        tool = PrivilegeEscalationTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(return_value={
            "success": True,
            "output": "...got system via technique 1 (Named Pipe Impersonation)",
        })

        result = await tool.execute(session_id=1, technique="getsystem")

        assert "getsystem" in result
        assert "Named Pipe" in result

    async def test_suggest_technique(self):
        """Test local exploit suggester."""
        tool = PrivilegeEscalationTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(return_value={
            "success": True,
            "output": "exploit/linux/local/cve_2021_4034_pwnkit",
        })

        result = await tool.execute(session_id=1, technique="suggest")

        assert "suggestions" in result.lower() or "suggest" in result.lower()
        assert "pwnkit" in result

    async def test_exploit_technique(self):
        """Test exploit technique with module_path."""
        tool = PrivilegeEscalationTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(return_value={
            "success": True,
            "session_opened": True,
            "output": "Elevated to root",
        })

        result = await tool.execute(
            session_id=1,
            technique="exploit",
            module_path="exploit/linux/local/cve_2021_4034_pwnkit",
        )

        assert "pwnkit" in result
        assert "New session opened: True" in result

    async def test_exploit_missing_module_path(self):
        """Test exploit technique without module_path returns error."""
        tool = PrivilegeEscalationTool()

        result = await tool.execute(session_id=1, technique="exploit")

        assert "Error" in result
        assert "module_path" in result

    async def test_unknown_technique(self):
        """Test unknown technique returns error."""
        tool = PrivilegeEscalationTool()

        result = await tool.execute(session_id=1, technique="magic")

        assert "Error" in result
        assert "Unknown technique" in result

    async def test_getsystem_failure(self):
        """Test getsystem when MCP returns error."""
        tool = PrivilegeEscalationTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(return_value={
            "success": False,
            "error": "Access denied",
        })

        result = await tool.execute(session_id=1, technique="getsystem")

        assert "Error" in result
        assert "Access denied" in result

    async def test_exception_handling(self):
        """Test handling unexpected exceptions."""
        tool = PrivilegeEscalationTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(side_effect=Exception("lost connection"))

        result = await tool.execute(session_id=1, technique="getsystem")

        assert "Error" in result
        assert "lost connection" in result
