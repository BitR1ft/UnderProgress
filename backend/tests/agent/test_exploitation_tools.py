"""Tests for exploitation tools (ExploitExecuteTool, BruteForceTool, SessionManagerTool)."""

import pytest
from unittest.mock import Mock, AsyncMock, patch
from app.agent.tools.exploitation_tools import (
    ExploitExecuteTool,
    BruteForceTool,
    SessionManagerTool,
    SERVICE_MODULE_MAP,
)


class TestExploitExecuteToolInit:
    """Test ExploitExecuteTool initialization and metadata."""

    def test_initialization(self):
        """Test tool initializes with correct name."""
        tool = ExploitExecuteTool()
        assert tool.name == "exploit_execute"

    def test_description(self):
        """Test tool has a description."""
        tool = ExploitExecuteTool()
        assert "Metasploit" in tool.description

    def test_custom_server_url(self):
        """Test tool accepts a custom server URL."""
        tool = ExploitExecuteTool(server_url="http://custom:9999")
        assert tool.client.server_url == "http://custom:9999"

    def test_parameters_schema(self):
        """Test tool metadata includes expected parameter keys."""
        tool = ExploitExecuteTool()
        props = tool.metadata.parameters["properties"]
        assert "module_path" in props
        assert "rhosts" in props
        assert "rport" in props
        assert "payload" in props
        assert "lhost" in props
        assert "lport" in props

    def test_required_parameters(self):
        """Test required parameters are module_path and rhosts."""
        tool = ExploitExecuteTool()
        required = tool.metadata.parameters["required"]
        assert "module_path" in required
        assert "rhosts" in required


class TestBruteForceToolInit:
    """Test BruteForceTool initialization and metadata."""

    def test_initialization(self):
        """Test tool initializes with correct name."""
        tool = BruteForceTool()
        assert tool.name == "brute_force"

    def test_description(self):
        """Test tool has a description."""
        tool = BruteForceTool()
        assert "brute force" in tool.description.lower()

    def test_parameters_schema(self):
        """Test tool metadata includes expected parameter keys."""
        tool = BruteForceTool()
        props = tool.metadata.parameters["properties"]
        assert "target" in props
        assert "service" in props
        assert "username" in props
        assert "wordlist" in props

    def test_required_parameters(self):
        """Test required parameters are target and service."""
        tool = BruteForceTool()
        required = tool.metadata.parameters["required"]
        assert "target" in required
        assert "service" in required


class TestSessionManagerToolInit:
    """Test SessionManagerTool initialization and metadata."""

    def test_initialization(self):
        """Test tool initializes with correct name."""
        tool = SessionManagerTool()
        assert tool.name == "session_manager"

    def test_description(self):
        """Test tool has a description."""
        tool = SessionManagerTool()
        assert "session" in tool.description.lower()

    def test_parameters_schema(self):
        """Test tool metadata includes expected parameter keys."""
        tool = SessionManagerTool()
        props = tool.metadata.parameters["properties"]
        assert "action" in props
        assert "session_id" in props
        assert "command" in props

    def test_action_enum(self):
        """Test that action parameter has list and command options."""
        tool = SessionManagerTool()
        action_enum = tool.metadata.parameters["properties"]["action"]["enum"]
        assert "list" in action_enum
        assert "command" in action_enum


class TestServiceModuleMap:
    """Test SERVICE_MODULE_MAP used by BruteForceTool."""

    def test_ssh_mapping(self):
        """Test SSH maps to correct module."""
        assert SERVICE_MODULE_MAP["ssh"] == "auxiliary/scanner/ssh/ssh_login"

    def test_ftp_mapping(self):
        """Test FTP maps to correct module."""
        assert SERVICE_MODULE_MAP["ftp"] == "auxiliary/scanner/ftp/ftp_login"

    def test_smb_mapping(self):
        """Test SMB maps to correct module."""
        assert SERVICE_MODULE_MAP["smb"] == "auxiliary/scanner/smb/smb_login"

    def test_mysql_mapping(self):
        """Test MySQL maps to correct module."""
        assert SERVICE_MODULE_MAP["mysql"] == "auxiliary/scanner/mysql/mysql_login"

    def test_postgres_mapping(self):
        """Test PostgreSQL maps to correct module."""
        assert SERVICE_MODULE_MAP["postgres"] == "auxiliary/scanner/postgres/postgres_login"

    def test_rdp_mapping(self):
        """Test RDP maps to correct module."""
        assert SERVICE_MODULE_MAP["rdp"] == "auxiliary/scanner/rdp/rdp_login"

    def test_telnet_mapping(self):
        """Test Telnet maps to correct module."""
        assert SERVICE_MODULE_MAP["telnet"] == "auxiliary/scanner/telnet/telnet_login"

    def test_vnc_mapping(self):
        """Test VNC maps to correct module."""
        assert SERVICE_MODULE_MAP["vnc"] == "auxiliary/scanner/vnc/vnc_login"

    def test_all_services_present(self):
        """Test all expected services are in the map."""
        expected = {"ssh", "ftp", "smb", "mysql", "postgres", "rdp", "telnet", "vnc"}
        assert set(SERVICE_MODULE_MAP.keys()) == expected


@pytest.mark.asyncio
class TestExploitExecuteToolExecute:
    """Test ExploitExecuteTool.execute() with mocked MCP client."""

    async def test_successful_exploitation(self):
        """Test successful exploit execution with session opened."""
        tool = ExploitExecuteTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(return_value={
            "success": True,
            "session_opened": True,
            "session_info": {"session_id": 1, "type": "meterpreter"},
            "output": "Exploit completed",
        })

        result = await tool.execute(
            module_path="exploit/unix/ftp/vsftpd_234_backdoor",
            rhosts="10.0.0.5",
            rport=21,
        )

        assert "10.0.0.5" in result
        assert "Session Opened: True" in result
        assert "Session ID: 1" in result
        tool.client.call_tool.assert_awaited_once()

    async def test_failed_exploitation(self):
        """Test exploit execution that returns an error."""
        tool = ExploitExecuteTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(return_value={
            "success": False,
            "error": "Connection refused",
        })

        result = await tool.execute(
            module_path="exploit/unix/ftp/vsftpd_234_backdoor",
            rhosts="10.0.0.5",
        )

        assert "Error" in result
        assert "Connection refused" in result

    async def test_exploitation_no_session(self):
        """Test exploit execution where no session is created."""
        tool = ExploitExecuteTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(return_value={
            "success": True,
            "session_opened": False,
            "session_info": None,
            "output": "",
        })

        result = await tool.execute(
            module_path="exploit/windows/smb/ms17_010",
            rhosts="10.0.0.10",
        )

        assert "No session was created" in result

    async def test_exploitation_exception(self):
        """Test exploit execution that raises an exception."""
        tool = ExploitExecuteTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(side_effect=ConnectionError("timeout"))

        result = await tool.execute(
            module_path="exploit/unix/ftp/vsftpd_234_backdoor",
            rhosts="10.0.0.5",
        )

        assert "Error" in result
        assert "timeout" in result


@pytest.mark.asyncio
class TestBruteForceToolExecute:
    """Test BruteForceTool.execute() with mocked MCP client."""

    async def test_successful_brute_force(self):
        """Test successful brute force execution."""
        tool = BruteForceTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(return_value={
            "success": True,
            "session_opened": True,
            "output": "Login successful: admin:password123",
        })

        result = await tool.execute(target="10.0.0.5", service="ssh", username="admin")

        assert "10.0.0.5" in result
        assert "ssh" in result
        assert "Session Opened: True" in result
        tool.client.call_tool.assert_awaited_once()

    async def test_unsupported_service(self):
        """Test brute force with unsupported service."""
        tool = BruteForceTool()

        result = await tool.execute(target="10.0.0.5", service="unknown_service")

        assert "Error" in result
        assert "Unsupported service" in result

    async def test_brute_force_failure(self):
        """Test brute force that returns an error."""
        tool = BruteForceTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(return_value={
            "success": False,
            "error": "Connection timed out",
        })

        result = await tool.execute(target="10.0.0.5", service="ftp")

        assert "Error" in result
        assert "Connection timed out" in result

    async def test_brute_force_exception(self):
        """Test brute force that raises an exception."""
        tool = BruteForceTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(side_effect=Exception("network error"))

        result = await tool.execute(target="10.0.0.5", service="ssh")

        assert "Error" in result
        assert "network error" in result


@pytest.mark.asyncio
class TestSessionManagerToolExecute:
    """Test SessionManagerTool.execute() with mocked MCP client."""

    async def test_list_sessions(self):
        """Test listing active sessions."""
        tool = SessionManagerTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(return_value={
            "success": True,
            "sessions": [
                {"id": 1, "type": "meterpreter", "info": "root @ 10.0.0.5"},
                {"id": 2, "type": "shell", "info": "www-data @ 10.0.0.6"},
            ],
        })

        result = await tool.execute(action="list")

        assert "Session 1" in result
        assert "Session 2" in result
        assert "meterpreter" in result

    async def test_list_no_sessions(self):
        """Test listing when no sessions are active."""
        tool = SessionManagerTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(return_value={
            "success": True,
            "sessions": [],
        })

        result = await tool.execute(action="list")

        assert "No active sessions" in result

    async def test_command_action(self):
        """Test executing a command in a session."""
        tool = SessionManagerTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(return_value={
            "success": True,
            "output": "uid=0(root) gid=0(root)",
        })

        result = await tool.execute(action="command", session_id=1, command="id")

        assert "Session 1" in result
        assert "id" in result
        tool.client.call_tool.assert_awaited_once()

    async def test_command_missing_session_id(self):
        """Test command action without session_id."""
        tool = SessionManagerTool()

        result = await tool.execute(action="command", command="id")

        assert "Error" in result
        assert "session_id" in result

    async def test_command_missing_command(self):
        """Test command action without command."""
        tool = SessionManagerTool()

        result = await tool.execute(action="command", session_id=1)

        assert "Error" in result
        assert "command" in result

    async def test_unknown_action(self):
        """Test unknown action returns an error."""
        tool = SessionManagerTool()

        result = await tool.execute(action="destroy")

        assert "Error" in result
        assert "Unknown action" in result

    async def test_list_sessions_error(self):
        """Test listing sessions when MCP returns an error."""
        tool = SessionManagerTool()
        tool.client = Mock()
        tool.client.call_tool = AsyncMock(return_value={
            "success": False,
            "error": "Server unavailable",
        })

        result = await tool.execute(action="list")

        assert "Error" in result
        assert "Server unavailable" in result
